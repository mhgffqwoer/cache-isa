# Кэш и кодирование команд

## Вариант 2.

## Инструментарий

> C++20, архитектура набора команд RISC-V

## Что реализовано

> Упрощенная версия работы. (Не уверен что все команды реализованны техничесски правильно)

# Описание:

**ISA:**
В файле `rv32.asm` представлен мой перевод из С в asm RISC-V. Пошагово объясню свои действия:

1. В данных строчках я инициализирую изначальные N, M, K.
   ```
   addi    s11, zero, 64	// M = 64
   addi    s10, zero, 60	// N = 60
   addi    s9, zero, 32	// K = 32
   ```
2. Посчитал значения адрессов памяти где будут начинаться наши массивы.
   ```
   pa = 0x100 (из условия)
   pb = 0x900 (pa + размеры массива а в байтах (64 * 32 = 2048 = 0x800))
   pc = 0x1800 (по аналогии pb + размер массива b в байтах (32 * 60 * 2))
   ```
3. Проинициализировал pa, pc, y = 0, x = 0, pb, s = 0, k = 0, тк числа слишком большие, кладу их по частям при помощи сдвигов.
   ```
   lui     s0, 0x100		// pa
   srli    s0, s0, 12
   lui     s1, 0x1800		// pc
   srli    s1, s1, 12
   addi    t0, zero, 0		// y = 0
   addi    t1, zero, 0		// x = 0
   lui     s2, 0x900		// pb
   srli    s2, s2, 12
   addi    s3, zero, 0		// s = 0
   addi    t2, zero, 0		// k = 0
   ```
4. Далее я выполняю `s += pa[k] * pb[x]` вот эту строчку, здесь несколько действий, высчитать адресс памяти pa[a] и pb[x] (еще учитывая типы данных самих массивов), получить данные из адресов, перемножить и прибавить их в S.
   ```
   add     t3, s0, t2		// pa[k] = k + pa
   slli    t4, t1, 1		// x * 2
   add     t4, t4, s2		// pb[x] = (x * 2) + pb
   lb      s4, 0, t3		// load
   lh      s5, 0, t4		// load
   mul     t3, s4, s5		// (sum) = pa[k] * pb[x]
   add     s3, s3, t3		// s += (sum)
   ```
5. В целом основные действия уже рассписаны и понятны, поэтому в остальных строках не происходит чего то нового, единственное я зацикливаю программу с помощью команды blt и выход из программы реализован через jalr. В качестве комментария к коду напишу что происходит.
   ```
   addi    s2, s2, 120		// pb += N
   addi    t2, t2, 1		// ++k
   blt     t2, s9, -36		// jump to string 14
   slli	t3, t1, 2		// x * 4
   add     t3, t3, s1		// pc[x] = (x * 4) + pc
   sw      s3, 0, t3		// store
   addi    t1, t1, 1		// ++x
   blt     t1, s10, -72	// jump to string 10
   addi    s0, s0, 32		// pa += K
   addi    s1, s1, 240		// pc += N
   addi    t0, t0, 1		// ++y
   blt     t0, s11, -92	// jump to string 9
   jalr    zero, ra, 0		// exit(0)
   ```

- не реализован транслятор asm->binary.

**Cache:**
Результат расчёта параметров системы:

| Параметры                | Системы                                            |
| ------------------------ | -------------------------------------------------- |
| MEM_SIZE                 | **512 Кбайт**                                      |
| ADDR_LEN                 | 19 бит (log2(MEM_SIZE))                            |
| Конфигурация кеша        | **look-through write-back**                        |
| Политики вытеснения кэша | **LRU и bit-pLRU**                                 |
| CACHE_WAY                | 4 (CACHE_LINE_COUNT / CACHE_SETS)                  |
| CACHE_TAG_LEN            | 10 (ADDR_LEN - CACHE_INDEX_LEN - CACHE_OFFSET_LEN) |
| CACHE_INDEX_LEN          | **4 бит**                                          |
| CACHE_OFFSET_LEN         | **5 бит**                                          |
| CACHE_SIZE               | **2048 байт**                                      |
| CACHE_LINE_SIZE          | 32 байта (2^OFFSET)                                |
| CACHE_LINE_COUNT         | 64 (CACHE_SIZE / CACHE_LINE_SIZE)                  |
| CACHE_SETS               | 16 (2^INDEX)                                       |

Реализация:
Вся реализация написана в файле `main.cpp`, работу вспомогательных функций, таких как HexToDec, LoadAndStoreArgs, class Arguments, не вижу смысла обяъяснять, в основном же вся работа выполняется в функции RunCommands и классах LRU и pLRU.

RunCommands:
Тут я просто эмитирую выполнение входного ассемблер файла, при написании опирался на [этот файл](https://cass-kul.github.io/files/riscv-card.pdf). В самом начале функции создал иммитацию регистров и памяти. Если команда подразумивает работу с кешом, то я подаю на добавление в кеш (offset, index). В этих строчках показано как я получаю эти переменные (при моем варианте параметров системы).

```cpp
int index = (registers[RegisterToIdx(arg)] >> 5) & 15;
int tag = (registers[RegisterToIdx(arg)] >> 9) & 1023;
```

Lru:
Я храню это в виде двумерного массива #define CACHE_SETS на CACHE_WAY в каждой ячейке которого храню LRULine (time, tag). При добавлении я сначала проверяю лежит ли обьект уже в кеше, если да то это попадание (++hits и обновляю значение time для этого обьекта), если нет то я ищу свободное место в методе Find, опираясь на время (time - отвечает за время когда был добавлен обьект в кеш).

pLru:
Храню тоже самое что и в Lru, но в кэш-линии вместо времени хранят (flag) бит. Когда мы находим нужную кэш линию, мы проверяем последняя ли это линия в сете, бит которой равен нулю. Если да, то ставим этой линии flag = 1, а остальным ставим flag = 0. Если она не последняя, то просто ставим в бит 1.
Если мы не находим нужную линию, то в данном сете мы находим первую кэш линию, у которой flag = 0 и заменяем его. Не забываем проверить, являлся ли он последним нулём в сете (если нужно обновляем сет).

Вот что выдет мне запуск программы:
```
$ clang++ -std=c++20 main.cpp -o main
$ ./main --asm "rv32.asm" --replacement 0
LRU     hit rate: 96.6571%
pLRU    hit rate: 96.6406%
```
